# -*- coding: utf-8 -*-
"""General_Disease_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12yw9uNuaKvrlHWDCu8V4Ppe0F7RLkQrE

# Add Dependencies
"""

import pandas as pd
import numpy as np
import joblib
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.metrics import accuracy_score

# Load Data
df = pd.read_csv("/content/DiseaseAndSymptoms.csv")

"""# Data Cleaning and Preprocessing"""

# Fill NaN values with empty strings
df.fillna("", inplace=True)

# Remove duplicate rows (ensuring train-test split integrity)
df.drop_duplicates(inplace=True)

# Combine all symptom columns into a list of symptoms
df['Symptoms'] = df.iloc[:, 1:].values.tolist()
df['Symptoms'] = df['Symptoms'].apply(lambda x: [symptom for symptom in x if symptom])

# Ensure at least 5 occurrences of each disease for better generalization
disease_counts = df['Disease'].value_counts()
df = df[df['Disease'].isin(disease_counts[disease_counts >= 5].index)]

"""# Encode Symptoms using MultiLabelBinarizer"""

mlb = MultiLabelBinarizer()
X = df['Symptoms']
y = df['Disease']

"""# Train Model"""

# Train-Test split using Stratified Sampling (prevent class imbalance)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# Fit the MultiLabelBinarizer **only on training data** to avoid leakage
mlb.fit(X_train)
X_train_encoded = mlb.transform(X_train)
X_test_encoded = mlb.transform(X_test)  # Test set is only transformed

"""# Training and Evaluatation of Model"""

# Model training with **Cross-Validation**
kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
best_model = None
best_accuracy = 0

for train_idx, val_idx in kfold.split(X_train_encoded, y_train):
    X_fold_train, X_fold_val = X_train_encoded[train_idx], X_train_encoded[val_idx]
    y_fold_train, y_fold_val = y_train.iloc[train_idx], y_train.iloc[val_idx]

    model = RandomForestClassifier(
        n_estimators=100,
        max_depth=8,  # Reduce depth to prevent memorization
        min_samples_split=10,  # Requires 10 samples per split
        min_samples_leaf=5,  # Requires 5 samples per leaf
        random_state=42
    )

    model.fit(X_fold_train, y_fold_train)
    val_pred = model.predict(X_fold_val)
    acc = accuracy_score(y_fold_val, val_pred)

    if acc > best_accuracy:
        best_accuracy = acc
        best_model = model  # Save best model

print(f"Best Cross-Validation Accuracy: {best_accuracy * 100:.2f}%")

# Final Model Training
best_model.fit(X_train_encoded, y_train)

# Evaluate on Train Set
y_train_pred = best_model.predict(X_train_encoded)
train_acc = accuracy_score(y_train, y_train_pred)
print(f"Final Test Accuracy: {train_acc * 100:.2f}%")

# Evaluate on Test Set
y_test_pred = best_model.predict(X_test_encoded)
test_acc = accuracy_score(y_test, y_test_pred)
print(f"Final Test Accuracy: {test_acc * 100:.2f}%")

"""# Predict Disease"""

# Disease Prediction Function
def predict_disease(user_symptoms):
    user_input = mlb.transform([user_symptoms])
    probabilities = best_model.predict_proba(user_input)[0]
    diseases = best_model.classes_

    # Sort diseases by probability and return top 3
    results = sorted(zip(diseases, probabilities), key=lambda x: x[1], reverse=True)[:3]
    return results

# Example prediction
user_symptoms = ["itching", "skin_rash", "nodal_skin_eruptions"]
predictions = predict_disease(user_symptoms)

print("Top 3 Predicted Diseases:")
for disease, probability in predictions:
    print(f"{disease}: {probability * 100:.2f}%")

"""# Save The Model"""

# Save the best model
joblib.dump(best_model, "disease_prediction_model.pkl")
joblib.dump(mlb, "symptom_encoder.pkl")