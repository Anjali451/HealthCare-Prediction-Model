# -*- coding: utf-8 -*-
"""Diabetes Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YgpjvqAxv7Y5UWaOZCBKK1lEgfRctut_

# Importing dependencies
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn.metrics import accuracy_score
import pickle
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

"""# Data Collection and Analysis"""

#Loading the dataset
diabetes_dataset = pd.read_csv('/content/Dataset of Diabetes .csv')

diabetes_dataset.head()

diabetes_dataset.shape

diabetes_dataset = diabetes_dataset.drop(columns = ['ID', 'No_Pation'], axis = 1)

#Getting Statistical Measures of the Data
diabetes_dataset.describe()

nan_count_class = diabetes_dataset.isna().sum()
print(f"Number of NaN values in 'CLASS' column: {nan_count_class}")

diabetes_dataset['Gender'] = diabetes_dataset['Gender'].str.strip()

diabetes_dataset['Gender'] = diabetes_dataset['Gender'].str.lower()

diabetes_dataset['Gender'].value_counts()

diabetes_dataset['Gender'].fillna('m', inplace=True)

diabetes_dataset['CLASS'] = diabetes_dataset['CLASS'].str.strip()

diabetes_dataset['CLASS'].value_counts()

diabetes_dataset.hist(figsize=(10,8))

diabetes_dataset.boxplot(figsize=(10,6))

diabetes_dataset['Gender'].value_counts().plot(kind='bar')

""" N --> Non- Diabetic
 Y --> Diabetic
 P --> Pre-Diabetic
"""

# Convert 'Gender' column to numerical representation before calculating the mean.
# 'F' to 0 and 'M' to 1:
diabetes_dataset['Gender'] = diabetes_dataset['Gender'].map({'f': 0, 'm': 1})

# Now you can calculate the mean:
diabetes_dataset.groupby('CLASS').mean()

sns.heatmap(diabetes_dataset.corr(numeric_only=True), annot=True)

#  Seperating the data and labels
X = diabetes_dataset.drop(columns = 'CLASS', axis = 1)
Y = diabetes_dataset['CLASS']

print(X)

print(Y)

"""# Data Standardization"""

scaler = StandardScaler()

scaler.fit(X)

with open('scaler.sav', 'wb') as scaler_file:
    pickle.dump(scaler, scaler_file)

standardized_data = scaler.transform(X)

print(standardized_data)

X = standardized_data
Y = diabetes_dataset['CLASS']

print(X)

print(Y)

"""# Train Test Split"""

X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.2, stratify=Y, random_state=2)

print(X.shape, X_train.shape, X_test.shape)

"""# Traning and Evaluating SVM Model




"""

classifer = svm.SVC(kernel='linear')

classifer.fit(X_train, Y_train)

# Accuracy Score on Training Data
X_train_prediction = classifer.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy score of the training data : ', training_data_accuracy)

# Accuracy Score on Test Data
X_test_prediction = classifer.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy score of the test data : ', test_data_accuracy)

# Step 1: Train the model
classifer.fit(X_train, Y_train)

# Step 2: Make predictions
y_pred = classifer.predict(X_test)

# Step 3: Generate confusion matrix
cm = confusion_matrix(Y_test, y_pred)

# Step 4: Visualize the confusion matrix
plt.figure(figsize=(6,4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel("Predicted Labels")
plt.ylabel("True Labels")
plt.title("Confusion Matrix")
plt.show()

from sklearn.metrics import classification_report

print(classification_report(Y_test, y_pred))

"""# Traning and Evaluating Random Forest Model"""

from sklearn.ensemble import RandomForestClassifier

# Initialize the Random Forest model
rf_model = RandomForestClassifier(n_estimators=200, max_depth=15, random_state=2, class_weight='balanced')

# Train the model
rf_model.fit(X_train, Y_train)

# Make predictions
Y_pred = rf_model.predict(X_test)

print("Train Accuracy:", rf_model.score(X_train, Y_train))
print("Test Accuracy:", rf_model.score(X_test, Y_test))

# Generate confusion matrix
cm = confusion_matrix(Y_test, Y_pred)

# Visualize the confusion matrix
plt.figure(figsize=(6,4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel("Predicted Labels")
plt.ylabel("True Labels")
plt.title("Confusion Matrix")
plt.show()

# Evaluate performance
print(classification_report(Y_test, Y_pred))

#Identify which features contribute most to prediction

# Fit the model to your training data
rf_model.fit(X_train, Y_train)

feature_importances = rf_model.feature_importances_
# Get feature names from the original DataFrame 'X' or 'diabetes_dataset'
feature_names = diabetes_dataset.drop(columns=['CLASS'], axis=1).columns # Assuming 'diabetes_dataset' is your original DataFrame

indices = np.argsort(feature_importances)[::-1]

plt.figure(figsize=(10, 6))
plt.title("Feature Importance in Random Forest")
plt.bar(range(len(feature_importances)), feature_importances[indices], align="center")
plt.xticks(range(len(feature_importances)), np.array(feature_names)[indices], rotation=90)
plt.show()

"""# Pridiction System

The SVM model performs well overall (94% accuracy).But it has poor recall for "P" (only 20%) that indicates it fails to capture many actual "P" cases.
So we are procedding with Random Forest model, as it is performing much better compared to the previous results
"""

input_data = (0, 34, 3.9, 81, 6, 6.2, 3.9, 0.8, 3.8, 1.8,	23)

# changing the input_data to numpy array
input_data_as_numpy_array = np.asarray(input_data)

# reshape the array as we are prdicting for one instance because we have trained the model for 768 instances it will expect that much of data and get confused
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

# we have standardized the data earlier so now we have to do the same
std_data = scaler.transform(input_data_reshaped)

prediction = rf_model.predict(std_data)
print(prediction)

prediction = rf_model.predict(std_data)
print(prediction)

if (prediction[0] == 'N'):
  print('The person is not diabetic')
if (prediction[0] == 'P'):
  print('The person is pre-diabetic')
else:
  print('The person is diabetic')

"""# Saving the model"""

filename = 'diabetes_model.sav'
pickle.dump(rf_model, open(filename, 'wb'))